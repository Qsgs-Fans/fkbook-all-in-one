开发草稿：UI逻辑代码重构
=========================

Freekill最后选择实现类似神杀AI的AI逻辑代码。然而神杀的AI代码存在的最大痛点
就是合法性判断相关的代码、乃至更多乱七八糟的代码不仅在客户端逻辑中出现了一次，
还需要在AI代码中重写一次。为了提高这里代码的重用性，需要对UI逻辑（which用到了
大量的合法判断逻辑）进行一次大重构，将大部分的判断全部从QML/JS搬到Lua代码中。

为此，我们需要先明确当前版本（0.4.19）中UI操作的逻辑（UI的外形设计暂且不谈），
更确切的说，与游戏对局有关联的UI逻辑——以出牌阶段请使用一张牌为例子，从客户端
收到服务器发送的Request消息开始：

1. Client(Cpp)首先收到消息，然后调用Lua函数
2. Lua视情况调用fk.client_callback中的函数，但一言以蔽之就是：

   * 解码收到的数据，更新Client(Lua)中的相关数据
   * 将原始数据转达给UI(qml) 也就是UI代码又要调用一遍JSON.parse

3. UI收到数据后，更新自己的相关数据，然后绘制所需要的UI组件；在整个操作过程中，
   UI组件的属性变更都依赖于client.lua以及client_util.lua中相关函数的功能。

   * 更确切的，当产生UI事件时（创建后、点击后、拖动后），都会调用某个JS函数，
     这些函数往往会对UI的某个属性进行更新。

   * 而这些JS函数往往会通过提供的接口对Lua进行调用，获取各种返回值以更新组件属性；
     这些Lua函数却又缺乏设计且效率低下，需要重新考虑

4. 操作结束后，拜托Client发回回复消息。

这些的缺点之前已经提过了，而如果进行重构的话，那么从QML调用Lua的步骤基本可以删去，
QML只要负责渲染以及将鼠标点击之类的事件传给Lua就行了，Lua负责计算所有的逻辑代码。

1. Client(Cpp)首先收到消息，然后调用Lua函数
2. Lua视情况调用fk.client_callback中的函数，但是：
   * 若发来的消息属于UI重构范围内的消息，则进入新逻辑
   * 否则和之前一样的逻辑，这也是为了便于继续使用老代码减少一段时间内的工作量
3. 若为新逻辑：Lua层面创建对应的RequestHandler对象；
4. RequestHandler根据数据进行初始化，然后调用notifyUI函数
5. QML中设置相应的applyChange函数处理notifyUI所需要的实际UI更新；
   与此同时，QML中各个UI组件的事件（例如点击、按下等）也会通过类似的方式传入到
   RequestHandler中，进而调用其update函数；update函数根据Lua中对组件逻辑的定义
   进行操作，最后再通过notifyUI将变动反映到UI中。

重要变动
-------------

Room.qml & RoomLogic.js
~~~~~~~~~~~~~~~~~~~~~~~~~

老代码中Room.qml有四种状态：

* notactive: 不活动状态；玩家现在在看别人操作或者看特效，没有自己要操作的事情
* response: 响应使用/打出/各种ActiveSkill
* playing: 出牌阶段专用
* replying: 其余所有操作，如是否发动xxx、所有无需操作Dashboard的操作

设置四种状态是因为使用、打出、出牌这些操作的逻辑相当复杂，而现在这些逻辑被放到
Lua中实现；因此新版本中只有两种状态：

* notactive: 无事可做
* active: 有事可做

对这种状态修改会导致依赖于 ``state == "replying"`` 之类的代码全部失效，这些一般
位于RoomLogic；这就是要干的活之一

Dashboard
~~~~~~~~~~~

现在绝大多数逻辑都处于Lua中，Dashboard中许多函数与属性处于作废状态；
一些依赖它们的UI组件（比如各种依赖 ``dashboard.is_pending`` 啥的）需要进行重写
